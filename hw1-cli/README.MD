# Задание №1. Задача про CLI

Требования и нюансы bash:
- команды `cat`, `echo`, `wc`, `pwd`, `exit`
- 'одинарные' и "двойные" кавычки (full and weak quoting)
- команды вида `var=value`, оператор `$var`
- вызов внешних программ
- пайплайны, т.е. оператор `|`

Артефакты на защиту:
- структурные диаграммы **классов** (~ программных сущностей) и **компонентов** (~ интерфейсов и пакетов Java)
- словесное описание работы системы

Результат: .md или .pdf файл в отдельной ветке, в пулл-реквесте, приложенный в LMS.

### Задачи

- Составить словарь предметной области (aka [Ubiquitous Language = Единый Язык](https://habr.com/ru/articles/232881/))
  Он должен содержать определения

* программе-интерпретатору,
* environment (раньше мы называли его контекстом),
* expression (любое валидное выражение на bash),
* подстановка (раскрытие операторов `$` и `$(...)`),
* поток ввода/вывода/ошибки,
* command (это непосредственно то, что нужно запустить, являющийся результатом применения всех вложенных подстановок. выполнить команду `kek -r 42 -- filename.txt` значит запустить исполняемый файл `kek`, сначала поискав его в текущей директории, затем в ENV_PATH с аргументами командной строки `-r 42 -- filename.txt` из рабочей директории, в которой мы находимся),
* embedded command (это та команда, которую мы встраиваем в наш интерпретатор сами. она не требует запуска настоящего процесса, хотя мы можем спроектировать, что даже они, кроме exit, будут отдельными исполняемыми файлами. это разумно, и в реальности так все и есть)
* рабочая директория (текущая директория, в которой работает интерпретатор)
* и др. возникающие

- Описать процесс от получения очередной строки до вывода результата эвалюации этого выражения в консоль

В реальной жизни это можно делать диаграммой последовательности, но нам хватит просто словесного описания. Evaluate expression =

- осуществить подстановки переменных и подвыражений
- синтаксически разобрать выражение как пайпы (выражение без пайпа – это вырожденный пайп длины 1), разобрать подвыражения пайпов (command), учтя операторы `<`, `>`, `>>`, `<<`, в итоге получив экземпляры `Expression = Command[]` (т.е. выражение – это список команд в пайпе).
- выполнить последовательно набор command, создавая необходимые дескрипторы ввода-вывода (для перенаправления потоков), перенаправлять потоки. результат исполнения выражения – это stdout последней команды пайплайна
- напечатать результат выражения в stdout интерпретатора

- Нарисовать диаграммы классов для программных сущностей, отвечающих данному процессу. Спроектировать программные интерфейсы классов, договориться о внутреннем API.

- Разбить классы на модули (в Java – будем пользоваться пакетами), добавить к классам интерфейсы, показать взаимосвязь модулей с помощью стрелок

### Инструменты

- Пробегитесь, если не понимаете, как работает bash-интерпретатор, по двум этим статьям [1](https://medium.com/geekculture/an-overview-of-the-working-of-the-bash-shell-f063e7f09945) и [2](https://medium.com/@hichamelmefeddel/building-a-shell-commands-interpreter-similar-to-bash-from-scratch-with-c-part-1-theory-64fdc141617d) (можно открыть в торе)

Особенно вспомните, что такое поток ввода-вывода, что такое fork и exec процесса (если вы не знаете).

- Для рисования диаграмм можно использовать `draw.io` и `visual paradigm online`. Их мы прикрепим в файл решения





